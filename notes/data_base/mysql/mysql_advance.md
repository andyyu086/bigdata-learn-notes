## 1. 索引
- 在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。
因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

## 2. 锁
### 2.1 锁粒度
- 根据锁的粒度区分为表级锁和行级锁，
- 表级锁，并发低，锁冲突高，加锁开销少，不易出现死锁；
- 行级锁，并发高，锁冲突低，加锁开销大，会出现死锁；
- 行级锁，根据锁的范围分类：Record Lock，Gap Lock，Next-key Lock;
- 在一些场景还是xuy使用表级锁的，比如：表大多数数据进行更新操作；事务过于复杂，使用行锁易出现死锁时。

### 2.2 读写方面
- 可以分为共享锁(S)和排它锁(X)
- 其中共享锁，其他事务已持有S锁的情况下，其他事务还可以持有S锁，但是不可以加排它锁；
- 对于排他锁，会阻止其他事务加任何类型的锁，直到该锁被释放。

### 2.3 死锁
- 一般避免死锁的方式：
    - 使用表级锁；
    - 尽量保证业务表访问顺序类似；
    - 尽量在事务中一次拿到依赖的锁开展，降低逐步加锁导致的死锁。

## 3. 大表优化
### 3.1 单表优化方面：
- 表定义方面
    - 对于INT类型，可以使用TINYINT SMALLINT MEDINUMINT类型最好，无符号用UNSIGNED;
    - VARCHAR 自动最大长度；
    - 对于重复的字符型类型，尝试使用枚举或者整体替换；
    - 避免使用NULL字段，WHERE子句中使用NULL会导致不使用索引，而是全表扫描；
    - 不用用字符型字段做主键，索引的话，字符字段用前缀索引；
- SQL方面
    - 外键和UNIQUE需求，可以的话，让程序来保证；
    - OR的使用 换成IN 来实现；
    - WHERE子句尽量避免!= <>操作符，否则会导致不使用索引，而是全表扫描。

### 3.2 缓存
- 自写式：同时写数据库和缓存，性能不高，可保证一致性；
- 回写式：先写缓存，再写数据库，性能较高，但是一致性比较难保证。

### 3.3 表分区
- 实现比较简单，可以只获取特定分区的数据，性能较高；
- 分区的定义一般可以使用RANGE 或者 HASH来做；
- 对于时间序列性较强的表，用时间分区较好，可以自然的区分好冷热数据，缓存也比较好配置。

### 3.4 垂直拆分
- 对单表的列级别的冷热数据进行拆分，使用相同的主键进行冗余链接；
- 进一步细化热数据，提高查询block和缓存的性能；
- 缺陷在于主键冗余，增加join的操作，事务处理更加复杂。

### 3.5 水平拆分
- 具体可以分为：分表和分库，分表就是对行级别主键进行分表操作，分区严格来说是特殊意义的分表；
- 分表解决不了单机的cpu或者id的瓶颈，需要分库来解决；
- 突破单表或单机数据量的限制，但是引入分布式事务和join的性能下降。
- 具体解决架构分为客户端架构和代理架构；典型的开源项目使用ShardingJDBC(客户端)，Mycat(代理)

### 3.6 参考
- [参考](https://segmentfault.com/a/1190000006158186)


