## Presto调优

### 存储调优

#### 1. 数据分区
- 对数据根据高频filter字段进行分区，可以大幅提高查询性能；
- 需要分析好高频查询的字段，进行partition设置；同时也要避免小文件太多，得控制好分区文件的大小；
- 当然，如果部分少量区分数据比较热，会导致单分区读受限；那就需要使用下面的分桶来处理。

#### 2. 数据分桶
- 对分区内数据也很多的场景下，使用hive的分桶操作；
- 主要是对区分度比较高的列，再进行分区内的分桶列设置，比如说user id等。

#### 3. 压缩算法
- 压缩操作可以降低文件的大小，从而减少网络读取传输的数据量，加快处理速度；
- 需要注意选择spilttable，默认选择parquet和ORC格式的；其次选择bzip2或者gzip

#### 4. 优化文件大小
- 尽量避免小文件太多的任务，如果小文件多，增加网络读取，文件源数据管理等成本；
- 使用合并等工具，尽可能进行小文件的合并。

#### 5. 列式数据存储配置
- 使用parquet和ORC格式时，可以对列级别的基于列的数据类型，选择不同的压缩算法，encoding方式，谓词下推等操作；
- 从而，大大过滤掉不需要读取的数据；提高读取效率。
- 对于parquet的block size和ORC的stripe size；默认为128MB和64MB；如果对于包含很多列的大表，可能需要考虑调大这个参数，以单block持续包含所有数据；
- 谓词下推，在parquet或者ORC的文件格式的头部具有部分统计消息，比如max和min值，这样可以快速过滤相关不需要的数据的读取；

##### 5.1 Schema设计 拍平
- 对于struct等复杂结果存储的；如果是比较热的字段，需要考虑进行相关嵌套内部字段的拍平设计操作；
- 这样可以，简单数据读取的量，而且可以简化SQL的编写。

### Query语句调优

#### 6. ORDER BY 语句
- 强烈建议加入LIMIT关键字进行数据输出限定；
- 因为ORDER BY会导致降所选字段全部获取到单节点，然后进行排序操作；如果数据量大会导致内存溢出；而且单点执行，性能也非常慢；
- 如果加入LIMIT操作，美国节点进行收集所选字段的时候就可以LIMIT限制这样，最后到单节点终排序的时候，数据量可以大大降低。

#### 7. JOIN 语句
- 两表JOIN，降大表在做表，小表在右边；这样可以以做表为主，读取右边小表进行JOIN；两个以上表的时候也是如此，根据表大小来设置；

#### 8. GROUP BY 语句
- GROUP BY操作也是根据相应的key，将数据缓存在内存中；比对key存在就进行加入生成等操作；
- 对于多列分组的情况下，将多样性大的列放到前面，少的放在后面，这样可以减少内存缓存的压力；比如说GROUP BY state,gender;
- 最后，可以的话，可以先进行filter操作之后，再进行groupby操作，这样可以减少输入分组的数据量；

#### 9. approximate等语句
- 在容错允许的情况下，使用此类语句，利用hash等进行去重操作，可以加快速度。

#### 10. 指定字段
- 只SELECT需要的必要字段，不要使用SELECT * 语句；加快整体数据的处理速度。


### 参考
https://docs.aws.amazon.com/zh_cn/athena/latest/ug/performance-tuning.html
https://aws.amazon.com/cn/blogs/big-data/top-10-performance-tuning-tips-for-amazon-athena/

